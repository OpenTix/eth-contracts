import { loadFixture } from "@nomicfoundation/hardhat-toolbox/network-helpers";
import { contracts } from "../typechain-types";
import { expect } from "chai";
import hre, { ethers } from "hardhat";
import { bigint } from "hardhat/internal/core/params/argumentTypes";
import { utils } from "../typechain-types/@openzeppelin/contracts";

// overall testing framework
describe("VenueMint", function () {

    // function for deploying
    // when called from loadFixture it will only actually be called once
    // then stored for later calls
    async function deployOne() {
        const VenueMint = await hre.ethers.getContractFactory("VenueMint");
        const contract = await VenueMint.deploy();
        return contract;
    }

    function genRandom(min: number, max: number) {
        const minCeiled = Math.ceil(min);
        const maxFloored = Math.floor(max);

        // return the random value
        return Math.floor(Math.random() * (maxFloored - minCeiled) + minCeiled);
    }

    // generously generated by google ai overview
    function getRandomElements<T>(list: T[], numElements: number): T[] {
        if (numElements > list.length) {
            throw new Error("Number of elements to select cannot be greater than the list length.");
        }
        
        const shuffled = [...list].sort(() => 0.5 - Math.random());
        return shuffled.slice(0, numElements);
    }

    // check core functionality of the contract
    describe("Core Functionality", function () {
        // check that the contract properly deploys
        it("should deploy", async () => {
            const contract = await loadFixture(deployOne);
            expect(contract).to.be;
        })

        // basic check to make sure the create_new_event function is creating NFTs
        // this checks that the contract owns the nft after creation
        it("can create an nft", async () => {
            const contract = await loadFixture(deployOne);
            await contract.create_new_event("test", "0xblahblahblah", 1, 0, [5])
            expect(await contract.balanceOfBatch([await contract.getAddress()], [0])).to.eql([1n])
        })

        // checks that purchasing a single ticket works with a separate user and vendor wallet
        it("can purchase single ticket", async () => {
            const init_contract = await loadFixture(deployOne);

            // vendor wallet and address
            const wallet = ethers.Wallet.createRandom().connect(ethers.provider);
            const address = await wallet.getAddress();

            // add a ton of fake money to the vendor wallet
            const vendor_contract_instance = init_contract.connect(wallet);

            ethers.provider.send("hardhat_setBalance", [address, "0xFFFFFFFFFFFFFFFFFFFFF"])
            
            // user wallet and address
            const userWallet = ethers.Wallet.createRandom().connect(ethers.provider);
            const userAddress = await userWallet.getAddress();
            
            // add a ton of fake money to the user wallet
            ethers.provider.send("hardhat_setBalance", [userAddress, "0xFFFFFFFFFFFFFFFFFFFFF"])
            
            // create the event
            const tmp = await vendor_contract_instance.create_new_event("test", address, 1, 0, [5000])
            
            // attach the contract to the user wallet
            // this means when we call the contracts functions the
            // sender (signer) will be the user wallet
            const user_contract_instance = vendor_contract_instance.connect(userWallet)

            // buy the tickets (way too much money give here)
            const resp = await user_contract_instance.buy_tickets("test", [0], {value: ethers.parseEther("1")});

            // check that the user wallet now owns the NFT
            expect(await user_contract_instance.balanceOfBatch([userAddress], [0])).to.eql([1n]);
        })

        // tests if 2 NFTs can be created
        it("can create multiple nfts", async () => {
            const contract = await loadFixture(deployOne);
            const contract_address = await contract.getAddress();
            await contract.create_new_event("test", contract_address, 2, 0, [5, 5]);
            expect(await contract.balanceOfBatch([contract_address, contract_address], [0,1])).to.eql([1n,1n])
        })

        // tests if the contract properly generates NFTs after generating other ones
        // does this for a relatively small number of NFTs
        it("can create 100-1000 NFTs", async () => {
            const contract = await loadFixture(deployOne);
            const contract_address = await contract.getAddress();
            let max = 10;
            let base = 100;
            let total_so_far = 0;

            for(let i = 1; i <= max; i++) {
                // create the events
                await contract.create_new_event(`test ${i*base}`, contract_address, i*base, 0, Array(i*base).fill(5));

                // check that the contract owns all the events
                expect(await contract.balanceOfBatch(Array(i*base).fill(contract_address), Array.from({length: i*base}, (_, i) => i + total_so_far))).to.eql(Array(i*base).fill(1n));
                total_so_far += i*max;
            }
        })

        it("can get the ids of an event", async () => {
            const contract = await loadFixture(deployOne);

            const tmp = await contract.create_new_event("test", "0xblahblah", 5, 0, [5,5,5,5,5]);

            // check that it returns properly for a valid and non valid event
            expect((await contract.get_event_ids("test"))[0]).to.eql(Array(0n,1n,2n,3n,4n));
            expect(contract.get_event_ids("")).to.rejectedWith(Error);
        })

        it("will update the available ids for an event", async () => {
            const contract = await loadFixture(deployOne);
            const user = ethers.Wallet.createRandom().connect(ethers.provider);
            const user_address = await user.getAddress();
            ethers.provider.send("hardhat_setBalance", [user_address, "0xFFFFFFFFFFFFFFFFFFFFF"])

            await contract.create_new_event("test", "0xblahblah", 5, 0, [5,5,5,5,5]);

            const user_contract_instance = contract.connect(user);
            await user_contract_instance.buy_tickets("test", [0], {value: ethers.parseEther("1")});

            expect((await contract.get_event_ids("test"))[0]).to.eql(Array(1n,2n,3n,4n))
        })

        it("will validate the description", async () => {
            const contract = await loadFixture(deployOne);

            const tmp = await contract.is_description_available("test");

            expect(tmp).to.equal(true);

            await contract.create_new_event("test", "tme", 1, 0, [1]);

            expect(await contract.is_description_available("test")).to.equal(false);
        })

        describe("User to User Ticket Transfer", function () {
            it("properly transfers tickets from user to user", async () => {
                const init_contract = await loadFixture(deployOne);
                
                // make wallets
                const nftholderwallet = ethers.Wallet.createRandom().connect(ethers.provider);
                const nftholderaddress = await nftholderwallet.getAddress();
                const nftpurchaserwallet = ethers.Wallet.createRandom().connect(ethers.provider);
                const nftpurchaseraddress = await nftpurchaserwallet.getAddress();
                
                // give both money
                ethers.provider.send("hardhat_setBalance", [nftholderaddress, "0xFFFFFFFFFFFFFFFFFFFFF"]);
                ethers.provider.send("hardhat_setBalance", [nftpurchaseraddress, "0xFFFFFFFFFFFFFFFFFFFFF"]);
                
                // make the holder instance and create the event
                const holder_instance = init_contract.connect(nftholderwallet);
                const tmp = await holder_instance.create_new_event("test", "cool beans", 1, 0, [2000]);
                
                // buy the tickets and give the contract permission to control the holders tokens
                const resp = await holder_instance.buy_tickets("test", [0], {value: ethers.parseEther("1")});
                const resp1 = await holder_instance.allow_user_to_user_ticket_transfer(0);
                
                // variable to check that we removed the contracts ability to control our tokens
                // a filter that allows us to only execute the function based on the holder and purchaser address
                var disallow_ran = false;
                const holderfilter = init_contract.filters.User_To_User_Transfer_Concluded(nftholderaddress, nftpurchaseraddress);
                
                // this is here purely for example (it is not necessary for our tests)
                // setup a listener that removes the contracts ability to manage the holders tokens
                holder_instance.on(holderfilter, async (response) => {
                    await holder_instance.disallow_user_to_user_ticket_transfer();
                    disallow_ran = true;
                });

                // create the purchaser instance
                const purchaser_instance = holder_instance.connect(nftpurchaserwallet);

                const holder_balance_before = await ethers.provider.getBalance(nftholderaddress);

                // make sure that the ticket buying function emits the correct events
                // make sure that the ticket was properly transfered from the two wallets
                expect(await purchaser_instance.buy_ticket_from_user(nftholderaddress,0, {value: ethers.parseEther("1")})).to.emit(purchaser_instance, "User_To_User_Transfer_Concluded").withArgs(nftholderaddress, nftpurchaseraddress);
                expect(await purchaser_instance.balanceOf(nftpurchaseraddress, 0)).to.equal(1n);

                // make sure the seller got the correct amount of money
                const holder_balance_after = await ethers.provider.getBalance(nftholderaddress);
                expect(holder_balance_after - holder_balance_before).to.equal(2000);

                // wait 5 seconds this is required for this to work right
                // explanation here: https://stackoverflow.com/questions/68432609/contract-event-listener-is-not-firing-when-running-hardhat-tests-with-ethers-js
                await new Promise(res => setTimeout(() => res(null), 5000));

                // make sure the listener caught the event
                expect(disallow_ran).to.equal(true);
            })
        })

        describe("Vendor Payment Functionality", function () {

            // checks that the vendor recieves the funds from one transaction
            it("properly pays the vendor", async () => {
                const init_contract = await loadFixture(deployOne);

                // randomly calculate cost of the ticket
                let ticket_cost = genRandom(5, 100000);

                // vendor wallet and address
                const wallet = ethers.Wallet.createRandom().connect(ethers.provider);
                const address = await wallet.getAddress();

                // add a ton of fake money to the vendor wallet
                const vendor_contract_instance = init_contract.connect(wallet);

                ethers.provider.send("hardhat_setBalance", [address, "0xFFFFFFFFFFFFFFFFFFFFF"])

                // user wallet and address
                const userWallet = ethers.Wallet.createRandom().connect(ethers.provider);
                const userAddress = await userWallet.getAddress();

                // add a ton of fake money to the user wallet
                ethers.provider.send("hardhat_setBalance", [userAddress, "0xFFFFFFFFFFFFFFFFFFFFF"])

                // create the event
                const tmp = await vendor_contract_instance.create_new_event("test", address, 1, 0, [ticket_cost]);

                // attach the contract to the user wallet
                // this means when we call the contracts functions the
                // sender (signer) will be the user wallet
                const user_contract_instance = vendor_contract_instance.connect(userWallet)

                const vendor_balance_before = await ethers.provider.getBalance(address);

                // buy the tickets (way too much money give here)
                const resp = await user_contract_instance.buy_tickets("test", [0], {value: ethers.parseEther("1")});

                const vendor_balance_after = await ethers.provider.getBalance(address);

                // check that the vendor wallet gained the correct amount of money
                expect(vendor_balance_after - vendor_balance_before).is.equal(ticket_cost);
            }) 

            // checks that the vendor is paid properly when batch buying tickets
            it("properly pays the vendor when batch buying multiple tickets", async () => {
                const init_contract = await loadFixture(deployOne);

                // randomly calculate cost of the ticket
                let ticket_cost = genRandom(5, 100000);

                // vendor wallet and address
                const wallet = ethers.Wallet.createRandom().connect(ethers.provider);
                const address = await wallet.getAddress();

                // add a ton of fake money to the vendor wallet
                const vendor_contract_instance = init_contract.connect(wallet);

                ethers.provider.send("hardhat_setBalance", [address, "0xFFFFFFFFFFFFFFFFFFFFF"])

                // user wallet and address
                const userWallet = ethers.Wallet.createRandom().connect(ethers.provider);
                const userAddress = await userWallet.getAddress();

                // add a ton of fake money to the user wallet
                ethers.provider.send("hardhat_setBalance", [userAddress, "0xFFFFFFFFFFFFFFFFFFFFF"])

                // create the event
                const tmp = await vendor_contract_instance.create_new_event("test", address, 2, 0, [ticket_cost, ticket_cost]);

                // attach the contract to the user wallet
                // this means when we call the contracts functions the
                // sender (signer) will be the user wallet
                const user_contract_instance = vendor_contract_instance.connect(userWallet)

                const vendor_balance_before = await ethers.provider.getBalance(address);

                // buy the tickets (way too much money give here)
                const resp = await user_contract_instance.buy_tickets("test", [0,1], {value: ethers.parseEther("1")});

                const vendor_balance_after = await ethers.provider.getBalance(address);

                // check that the vendor wallet gained the correct amount of money
                expect(vendor_balance_after - vendor_balance_before).is.equal(ticket_cost*2);
            })

            // checks that the vendor is paid properly when buying multiple tickets separately
            it("properly pays the vendor when buying multiple tickets in individual transactions", async () => {
                const init_contract = await loadFixture(deployOne);
                
                // randomly calculate cost of the ticket
                let ticket_cost = genRandom(5, 100000);

                // vendor wallet and address
                const wallet = ethers.Wallet.createRandom().connect(ethers.provider);
                const address = await wallet.getAddress();

                // add a ton of fake money to the vendor wallet
                const vendor_contract_instance = init_contract.connect(wallet);

                ethers.provider.send("hardhat_setBalance", [address, "0xFFFFFFFFFFFFFFFFFFFFF"])

                // user wallet and address
                const userWallet = ethers.Wallet.createRandom().connect(ethers.provider);
                const userAddress = await userWallet.getAddress();

                // add a ton of fake money to the user wallet
                ethers.provider.send("hardhat_setBalance", [userAddress, "0xFFFFFFFFFFFFFFFFFFFFF"])

                // create the event
                const tmp = await vendor_contract_instance.create_new_event("test", address, 2, 0, [ticket_cost, ticket_cost]);

                // attach the contract to the user wallet
                // this means when we call the contracts functions the
                // sender (signer) will be the user wallet
                const user_contract_instance = vendor_contract_instance.connect(userWallet)

                const vendor_balance_before = await ethers.provider.getBalance(address);

                // buy the tickets (way too much money give here)
                const resp = await user_contract_instance.buy_tickets("test", [0], {value: ethers.parseEther("1")});
                const resp2 = await user_contract_instance.buy_tickets("test", [1], {value: ethers.parseEther("1")});
                
                const vendor_balance_after = await ethers.provider.getBalance(address);
                
                // check that the vendor wallet gained the correct amount of money
                expect(vendor_balance_after - vendor_balance_before).is.equal(ticket_cost*2);
            })

            // checks that the vendor is paid properly when mutliple users buy a ticket
            it("properly pays the vendor when multiple users buy a ticket", async () => {
                const init_contract = await loadFixture(deployOne);
                
                // randomly calculate cost of the ticket
                let ticket_cost = genRandom(5, 100000);

                // vendor wallet and address
                const wallet = ethers.Wallet.createRandom().connect(ethers.provider);
                const address = await wallet.getAddress();

                // add a ton of fake money to the vendor wallet
                const vendor_contract_instance = init_contract.connect(wallet);

                ethers.provider.send("hardhat_setBalance", [address, "0xFFFFFFFFFFFFFFFFFFFFF"])

                // user wallet and address
                const userWallet = ethers.Wallet.createRandom().connect(ethers.provider);
                const userAddress = await userWallet.getAddress();

                // add a ton of fake money to the user wallet
                ethers.provider.send("hardhat_setBalance", [userAddress, "0xFFFFFFFFFFFFFFFFFFFFF"])

                // second user wallet and address
                const userWallet2 = ethers.Wallet.createRandom().connect(ethers.provider)
                const userAddress2 = await userWallet2.getAddress()

                // add a ton of fake money to the second user wallet
                ethers.provider.send("hardhat_setBalance", [userAddress2, "0xFFFFFFFFFFFFFFFFFFFFF"])

                // create the event
                const tmp = await vendor_contract_instance.create_new_event("test", address, 2, 0, [ticket_cost, ticket_cost]);

                // attach the contract to the user wallet
                // this means when we call the contracts functions the
                // sender (signer) will be the user wallet
                const user_contract_instance = vendor_contract_instance.connect(userWallet);

                const vendor_balance_before = await ethers.provider.getBalance(address);

                // buy the tickets (way too much money give here)
                const resp = await user_contract_instance.buy_tickets("test", [0], {value: ethers.parseEther("1")});

                const user2_contract_instance = user_contract_instance.connect(userWallet2);

                const resp2 = await user2_contract_instance.buy_tickets("test", [1], {value: ethers.parseEther("1")});
                
                const vendor_balance_after = await ethers.provider.getBalance(address);
                
                // check that the vendor wallet gained the correct amount of money
                expect(vendor_balance_after - vendor_balance_before).is.equal(ticket_cost*2);
            })

            // checks that the vendor is paid properly when mutliple users buy multiple tickets
            it("properly pays the vendor when multiple users buy multiple tickets", async () => {
                const init_contract = await loadFixture(deployOne);
                
                // randomly calculate cost of the ticket
                let ticket_cost = genRandom(5, 100000);

                // vendor wallet and address
                const wallet = ethers.Wallet.createRandom().connect(ethers.provider);
                const address = await wallet.getAddress();

                // add a ton of fake money to the vendor wallet
                const vendor_contract_instance = init_contract.connect(wallet);

                ethers.provider.send("hardhat_setBalance", [address, "0xFFFFFFFFFFFFFFFFFFFFF"])

                // user wallet and address
                const userWallet = ethers.Wallet.createRandom().connect(ethers.provider);
                const userAddress = await userWallet.getAddress();

                // add a ton of fake money to the user wallet
                ethers.provider.send("hardhat_setBalance", [userAddress, "0xFFFFFFFFFFFFFFFFFFFFF"])

                // second user wallet and address
                const userWallet2 = ethers.Wallet.createRandom().connect(ethers.provider)
                const userAddress2 = await userWallet2.getAddress()

                // add a ton of fake money to the second user wallet
                ethers.provider.send("hardhat_setBalance", [userAddress2, "0xFFFFFFFFFFFFFFFFFFFFF"])

                // create the event
                const tmp = await vendor_contract_instance.create_new_event("test", address, 4, 0, [ticket_cost, ticket_cost, ticket_cost, ticket_cost]);

                // attach the contract to the user wallet
                // this means when we call the contracts functions the
                // sender (signer) will be the user wallet
                const user_contract_instance = vendor_contract_instance.connect(userWallet);

                const vendor_balance_before = await ethers.provider.getBalance(address);

                // buy the tickets (way too much money give here)
                const resp = await user_contract_instance.buy_tickets("test", [0,1], {value: ethers.parseEther("1")});

                const user2_contract_instance = user_contract_instance.connect(userWallet2);

                const resp2 = await user2_contract_instance.buy_tickets("test", [2,3], {value: ethers.parseEther("1")});
                
                const vendor_balance_after = await ethers.provider.getBalance(address);

                // check that the vendor wallet gained the correct amount of money
                expect(vendor_balance_after - vendor_balance_before).is.equal(ticket_cost*4);
            })
        })

        // so the goal here is to have random number of vendors generate a random
        // number of events with a random numbers of tickets and have a random number of clients buy
        // a random number of tickets from a random event and then check that the vendor was payed correctly and
        // that the user owns the correct tickets
        describe("Final Overarching Test", async function () {
            it("should work great", async () => {
                // gen a ton of random values
                let number_vendors = genRandom(2, 20);
                let number_clients = number_vendors;

                let vendor_data = Array();
                let vendor_event_nums = Array();
                let total_bought_from_vendor = Array(number_vendors).fill(0);
                let vendor_before_balance = Array(number_vendors);
                let vendor_after_balance = Array(number_vendors);

                // get the contract
                let contract = await loadFixture(deployOne);

                // create the vendors
                let vendors = Array(number_vendors);
                
                // setup the vendors
                for(let i = 0; i < number_vendors; i++) {
                    let number_events = genRandom(1,20);
                    vendor_event_nums.push(number_events);

                    let tmp_array = Array();

                    vendors[i] = ethers.Wallet.createRandom().connect(ethers.provider);
                    let address = await vendors[i].getAddress();

                    // give the vendor some money so it can generate tickets
                    ethers.provider.send("hardhat_setBalance", [address, "0xFFFFFFFFFFFFFFFFFFFFF"])

                    let vendor_contract = contract.connect(vendors[i]);

                    for(let j = 0; j < number_events; j++) {
                        let ticket_cost = genRandom(5,20000);
                        let number_tickets = genRandom(1,500);
                        let event_name = `vendor ${i} event ${j}`;

                        await vendor_contract.create_new_event(event_name, `i am vendor ${i}`, number_tickets, 0, Array(number_tickets).fill(ticket_cost));

                        tmp_array.push({ticket_cost, number_tickets, event_name});
                    }

                    vendor_before_balance[i] = await ethers.provider.getBalance(address);

                    vendor_data.push(tmp_array);
                }

                let client_data = Array();
                let clients = Array(number_clients);

                let client_vendor_mapping = Array.from({length: number_vendors}, (_, i) => i + 1).sort(() => Math.random() - 0.5).map(num => num-1);
                
                // setup the clients and have them buy
                for (let i = 0; i < number_clients; i++) {
                    let num_events = vendor_event_nums[client_vendor_mapping[i]];
                    let number_events_to_purchase_from = genRandom(1, num_events);

                    // long line but basically:
                    // makes list from 0->num_events then randomly pulls number_events_to_purchase_from events from it
                    let events_index_array = getRandomElements(Array.from({length: num_events}, (_, i) => i + 1).map(num => num-1), number_events_to_purchase_from);

                    clients[i] = ethers.Wallet.createRandom().connect(ethers.provider);
                    let address = await clients[i].getAddress();

                    // give the client some money so it can purchase tickets
                    ethers.provider.send("hardhat_setBalance", [address, "0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"])

                    let client_contract = contract.connect(clients[i]);

                    // gotta figure out our ids now (fuck)
                    // after a 1.5 hour excursion that works (yay!)
                    let event_ticket_purchases = Array();
                    for (let j = 0; j < number_events_to_purchase_from; j++) {

                        let event_data = vendor_data[client_vendor_mapping[i]][events_index_array[j]];
                        //console.log(event_data);
                        let num_tickets_to_purchase = genRandom(1, event_data['number_tickets']);

                        let tickets_to_purchase = [...(await client_contract.get_event_ids(event_data['event_name']))[0].slice(0, num_tickets_to_purchase)];
                        
                        let local_cost = num_tickets_to_purchase * event_data['ticket_cost'];
                        // update total for total money vendor should have
                        total_bought_from_vendor[client_vendor_mapping[i]] += local_cost;

                        await client_contract.buy_tickets(event_data['event_name'], tickets_to_purchase, {value: ethers.parseEther("1") + BigInt(local_cost)});

                        event_ticket_purchases.push(tickets_to_purchase);
                    }
                    
                    client_data.push({number_events_to_purchase_from, event_ticket_purchases});
                }

                // get the vendors balance after the transaction
                for (let i = 0; i < number_vendors; i++) {
                    vendor_after_balance[i] = await ethers.provider.getBalance(await vendors[i].getAddress());
                }

                // make sure all the vendors got the right amount of money
                for (let i = 0; i < number_vendors; i++) {
                    let diff = vendor_after_balance[i] - vendor_before_balance[i];

                    expect(diff).to.equal(total_bought_from_vendor[i]);
                }

                // make sure the clients own all the tickets they bought
                for (let i = 0; i < clients.length; i++) {
                    let big_ol_list = client_data[i]['event_ticket_purchases'];
                    
                    for (let j = 0; j < big_ol_list.length; j++) {
                        expect(await contract.balanceOfBatch(Array(big_ol_list[j].length).fill(await clients[i].getAddress()), big_ol_list[j])).to.eql(Array(big_ol_list[j].length).fill(1n));
                    }
                }
            })
        })
    })
})
